---
layout:     post
title:      C++构建Matrix类(8)
subtitle:   matrix-c求解矩阵的实特征值
date:       2021-02-26
author:     Welt Xing
header-img: img/matrix_equations.png
catalog:    true
categories: matrix-c
tags:
    - matrix-c
    - 线性代数
---

# 实现特征值的求解

## 关于特征值和特征向量

简单地说，方阵$A$的特征值$\lambda$和特征向量$\vec v$满足如下等式：

$$
A\vec{v}=\lambda\vec{v}(\vec{v}\neq0)
$$

进一步变换：

$$
(A-\lambda E)\vec{v}=0
$$

我们在之前求解齐次线性方程组提到过，如果方阵$A-\lambda E$满秩，那么$\vec{v}$恒为$0$，所以要有非$0$的$\vec{v}$，则该方阵非满秩，等价于行列式为0：

$$
\det(A-\lambda E)=0
$$

以矩阵

$$
\begin{bmatrix}
1&0\\
-\frac{1}{2}&1
\end{bmatrix}
$$

为例：

$$
\det(\begin{bmatrix}
1&0\\
-\frac{1}{2}&1
\end{bmatrix}-\lambda\begin{bmatrix}
1&0\\
0&1\\
\end{bmatrix})=\det(\begin{bmatrix}
1-\lambda&0\\
-\frac{1}{2}&1-\lambda\\
\end{bmatrix})=(1-\lambda)^2=0
$$

解得特征值为$1$，我们只需要再解一个多解的齐次线性方程组：

$$
\begin{bmatrix}
0&0\\
-\frac{1}{2}&0\\
\end{bmatrix}x=0
$$

$x$就是特征值对应的特征向量。

我们并不打算用求解行列式方程的形式去求特征值，因为设置未知数和求解方程在`matrix-c`中并不支持。更一般的，我们会使用迭代算法求解此类问题（甚至存在用迭代法求解线性方程组的算法）。此问题常用$QR$算法

## QR分解

$QR$算法依赖矩阵的$QR$分解，矩阵分解会在后面的文章中介绍讲解，在此只简单讲一下$QR$分解的模式：

$$
A_{m\times n}=Q_{m\times m}R_{m\times n}(m\geq n)
$$

其中$Q$是一个正交矩阵($QQ^\top=I$)，$R$是一个上三角矩阵。

`matrix-c`已经实现了对一个方阵($m=n$)的$QR$分解，`QR_decomposition`，直接使用即可：

```cpp
// 为使代码简介，将pair<Matrix, Matrix>替换成matrix_pair
#define matrix_pair std::pair<Matrix, Matrix>

using namespace std;
int main() {
    // A是一个4*4的随机矩阵，元素都在[-10, 10]内
    Matrix A = rand_matrix(4, 4, -10, 10); 
    // 
    matrix_pair result = QR_decomposition(A);
    Matrix Q = result.first, R = result.second;
    cout << A << " = " << Q << " * " << R << endl;
    printf("验证：Q * R = ");
    cout << Q * R << endl; // 验证分解结果
    return 0;
}
```

程序执行结果：![测试结果](/img/QR_test.png)

对照$A$和$Q\times R$，完全一致。

## QR算法

QR算法可以通过迭代求得实矩阵的实特征值：

$$
\begin{aligned}
&QR-ALGORITHM(A):\\
&for\;\;i\gets1\;\;to\;\;N:\\
&\qquad Q,R=QR-DECOMPOSITION(A)\\
&\qquad A\gets RQ\\
&\qquad if\;A\;is\;a\;upper\;triangular\;matrix:\\
&\qquad\qquad break\\
&return\;\;A
\end{aligned}
$$

此时$A$的特征值必然在算法所返回矩阵的对角线上。

之所以结论不是“A的特征值就是算法返回矩阵的对角线元素”，是因为该算法只能求出实特征值，当时猜测对角线上的非实特征值元素可能对应复特征值的实部，后来的测试否定了这一猜想。

代码实现是不难的：

```cpp
Matrix QR_iteration(Matrix m) {
    Matrix Q, R, A = m, T;
    int n = m.get_column_number();
    bool end = true;
    for (int i = 0; i < QR_ITERATION; i++) {
        matrix_pair p = QR_decomposition(A);
        Q = p.first, R = p.second;
        A = R * Q;
        if (is_upper_tri(A)) {
            break;
        }
    }
    return A;
}
```

