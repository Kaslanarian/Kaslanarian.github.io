---
layout:     post
title:      C++构建矩阵类(4)
subtitle:   行列式和逆矩阵
date:       2021-02-22
author:     Welt Xing
header-img: img/matrix4_header.png
catalog:    true
categories: matrix-c
tags:
    - matrix-c
    - 线性代数
---

# C++, Det and Inverse

## 行列式的计算方法

### 代数余子式法

对于矩阵$A_{n\times n}$，其行列式为：

$$
\det(A)=\sum_{i=1}^n a_{i1}A_{i1}=\sum_{i=1}^n a_{1i}A_{1i}
$$

不论是按行展开还是列展开，时间复杂度都是$n^3$:

$$
T(n)=\sum_{i=1}^n T(n-1)=nT(n-1)\to T(n)=\Theta(n^3)
$$

使用递归函数就可以实现，但对于我们的矩阵类来说，计算代数余子式需要删去该元素所在的行和列，再进行计算：

$$
T(n)=\sum_{i=1}^n[T(n-1)+2n]
$$

虽然时间复杂度在渐进意义上没有变化，但还是花费更多时间，所以我们再看看下一种求法，也就是化为上/下三角矩阵再求矩阵对角线上元素的积。

### 化为上三角矩阵求行列式

$$
\begin{aligned}
&\det(A):\\
&sign\gets1,ret\gets 1\\
&for\;\;i\gets1\;\;to\;\;n-1:\\
&\qquad if\;\;A(i,i)=0:\\
&\qquad\qquad exch\gets false\\
&\qquad\qquad for\;\;j\gets i+1\;\;to\;\; n:\\
&\qquad\qquad\qquad if\;\;A(j,i)\neq0:\\
&\qquad\qquad\qquad\qquad swap\;the\;i^{th}\;row\;with\;j^{th}\;row\\
&\qquad\qquad\qquad\qquad exch\gets true\\
&\qquad\qquad\qquad\qquad sign\gets -1\times sign\\
&\qquad\qquad if\;exch=false:\\
&\qquad\qquad\qquad return\;0;\\
&\qquad for\;\;k\gets i+1\;\;to\;\;n:\\
&\qquad\qquad A(k)\gets A(k)-A(i)\times\dfrac{A(k,i)}{A(i,i)}\\
&\qquad ret\gets ret\times A(i,i)\\
& return\;\; sign\times ret
\end{aligned}
$$

算法进行$n-1$次循环，每次循环利用倍加行变换将第$i$列的第$i+1$行至第$n$行的元素置为0，以此化成一个上三角矩阵，其行列式就是对角线的乘积。

在每一轮行变换开始之前，我们必须判断对角线元素是否为0，不然在

$$
A(k)\gets A(k)-A(i)\times\dfrac{A(k,i)}{A(i,i)}
$$

中会出现除0异常，所以我们可以将第$i$行与下面的某一行交换，当然这样的行要满足第$i$列元素不为0。如果找不到这样的行，说明第$i$行的第$i\sim n$列都是0，那么可以推得该行列式就是0。

我们找到这样的行后，就会对这两行进行交换，我们知道交换操作会导致$\det$成为其相反数，所以我们用`sign`来记录行交换次数，如果在整个算法中交换了偶数次，那么正好抵消，否则在计算出对角线乘积后还要取相反数才是最终结果。

时间复杂度：

$$
\begin{aligned}
T(n)&=\sum_{i=1}^{n-1}[O(n-i)+(n-i)\times n]=O(n^3)
\end{aligned}
$$

其中$O(n-i)$是向下搜索满足条件的行所需要的时间，$(n-i)\times n$就是倍增行变换的时间；

### Matrix-C中的行列式算法

在实际代码中，我们采取上面两种方法的折中：

$$
\begin{aligned}
&\det(A, n):\\
&if\;\;n=1:\\
&\qquad return\;\;A(1,1)\\
&exch\gets false\\
&if\;\;A(n,n)=0:\\
&\qquad for\;\;i\gets1\;\;to\;\;n-1:\\
&\qquad\qquad if\;\;A(i,n)\neq0:\\
&\qquad\qquad\quad swap\;the\;i^{th}\;row\;with\;n^{th}\;row\\
&\qquad\qquad\quad exch\gets true\\
&\qquad if\;\; exch\neq true:\\
&\qquad\qquad return\;\;0\\
&for\;\;j\gets 1\;\;to\;\;n-1:\\
&\qquad A(j)\gets A(j)-A(n)\times\dfrac{A(j,n)}{A(n,n)}\\
&if\;\;exch=false:\\
&\qquad return\;\;A(n,n)\times\det(A, n-1)\\
&else:\\
&\qquad return\;\;-A(n,n)\times\det(A, n-1)
\end{aligned}
$$

在算法中，我们将最后一列第$1\sim n-1$行的元素通过倍加行变换置为0，这样根据代数余子式的公式：

$$
\det(A)=a_{nn}A_{nn}
$$

$A_{nn}$则可以通过递归求出来，当然如果交换了行，由此产生的负号不能忘记了。

这样的写法本质上还是化为下三角矩阵求行列式，只不过通过递归减少了代码量，同时函数参数考虑了矩阵尺寸$n$，使得我们可以在不删除行/列的情况下计算代数余子式。

时间复杂度：

$$
T(n)=O(n^2)+T(n-1)=O(n^3)
$$

具体的代码实现可以参考[det in matrix-C](https://github.com/Kaslanarian/matrix-C/blob/master/src/math_helper.cc)，其中伪代码中的$A$是用指针实现的，使得递归中的行变换具有效性。

### 程序测试

运行程序：

```cpp
int main() {
    int n;
    std::cin >> n; // 输入方阵的size
    Matrix m = Matrix(n, n);
    std::cin >> m; // 输入矩阵
    std::cout << det(m) << std::endl;
    return 0;
}
```

实现效果图：

![行列式测试](/img/det.png)

## 逆矩阵的计算方法

线性代数中的2个求逆矩阵的基本算法：

1. 伴随矩阵法；

2. 高斯消元法

### 伴随矩阵法求逆矩阵

伴随矩阵$A*$的第$i$行第$j$列是矩阵$A$删去第$j$行第$i$列后的行列式：

$$
A^*=
\begin{bmatrix}
A_{11} & A_{21} & \cdots & A_{n1}\\
A_{12} & \ddots &        & \vdots\\
\vdots & & \ddots & \vdots\\
A_{1n} & \cdots & A_{n-1,n}&A_{nn}
\end{bmatrix}
$$

如果$A$可逆，那么有：

$$
A^{-1}=\dfrac{A^*}{\det(A)}
$$

时间复杂度：

$$
\begin{aligned}
T(n)
&=T(计算A行列式)+T(计算n^2个余子式)\\
&=O(n^3)+n^2 O((n-1)^3)\\
&=O(n^5)
\end{aligned}
$$

从时间复杂度上解释了当时觉得该算法繁琐的原因。

### 高斯消元法

相比于伴随矩阵求逆矩阵，高斯消元法更加简便和常用。

假设我们要求

$$
A=
\begin{bmatrix}
a & b & c\\
d & e & f\\
g & h & i\\
\end{bmatrix}
$$

的逆矩阵，我们只需要将一个单位矩阵与其合并，形成一个$n\times 2n$的矩阵：

$$
(A|E)=
\begin{bmatrix}
a & b & c & 1 & 0 & 0\\
d & e & f & 0 & 1 & 0\\
g & h & i & 0 & 0 & 1\\
\end{bmatrix}
$$

对$(A|E)$进行初等行变换，使得左半部分为单位矩阵：

$$
\begin{bmatrix}
a & b & c & 1 & 0 & 0\\
d & e & f & 0 & 1 & 0\\
g & h & i & 0 & 0 & 1\\
\end{bmatrix}
\longrightarrow
\begin{bmatrix}
1 & 0 & 0 & r & s & t\\
0 & 1 & 0 & u & v & w\\
0 & 0 & 1 & x & y & z\\
\end{bmatrix}
$$

右半部分即为$A$的逆矩阵。

时间复杂度：

$$
\begin{aligned}
T(n)
&=T(化为下三角矩阵)+T(继续化为单位矩阵)\\
&=2T(化为下三角矩阵)\\
&=O(n^3)
\end{aligned}
$$

显然比伴随矩阵算法简便，`matrix-C`正选取第二种算法。如果$A$行列式为0，也就是没有逆矩阵，那么高斯消元之后的$n\times 2n$矩阵中$A(i,i)$必然有一个为0。

逆矩阵函数`inv`函数代码在[math_helper.cc](https://github.com/Kaslanarian/matrix-C/blob/master/src/math_helper.cc)中

### 程序测试

执行如下测试程序：

```cpp
using namespace std;
int main() {
    int n;
    cin >> n;
    Matrix A = Matrix(n, n);
    printf("输入%d*%d矩阵，以求逆矩阵\n", n, n);
    cin >> A;
    Matrix inverse = inv(A);
    // 测试逆矩阵是否正确
    cout << A << " * " << inverse << " = "<< inverse * A << endl;
    return 0;
}
```

实现效果：

![逆矩阵效果](/img/inv.png)

可以看出我们的逆矩阵算法实现成功。