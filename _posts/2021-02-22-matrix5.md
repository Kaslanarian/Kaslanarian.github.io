---
layout:     post
title:      C++构建Matrix类(4)
subtitle:   行列式和逆矩阵
date:       2021-02-22
author:     Welt Xing
header-img: img/matrix4_header.png
catalog: true
tags:
    - Matrix
    - C/C++
---

# C++, Det and Inverse

## 行列式的计算方法

### 代数余子式法

对于矩阵$A_{n\times n}$，其行列式为：

$$
\det(A)=\sum_{i=1}^n a_{i1}A_{i1}=\sum_{i=1}^n a_{1i}A_{1i}
$$

不论是按行展开还是列展开，时间复杂度都是$n^3$:

$$
T(n)=\sum_{i=1}^n T(n-1)=nT(n-1)\to T(n)=\Theta(n^3)
$$

使用递归函数就可以实现，但对于我们的矩阵类来说，计算代数余子式需要删去该元素所在的行和列，再进行计算：

$$
T(n)=\sum_{i=1}^n[T(n-1)+2n]
$$

虽然时间复杂度在渐进意义上没有变化，但还是花费更多时间，所以我们再看看下一种求法，也就是化为上/下三角矩阵再求矩阵对角线上元素的积。

### 化为上三角矩阵求行列式

$$
\begin{aligned}
&\det(A):\\
&sign\gets1,ret\gets 1\\
&for\;\;i\gets1\;\;to\;\;n-1:\\
&\qquad if\;\;A(i,i)=0:\\
&\qquad\qquad exch\gets false\\
&\qquad\qquad for\;\;j\gets i+1\;\;to\;\; n:\\
&\qquad\qquad\qquad if\;\;A(j,i)\neq0:\\
&\qquad\qquad\qquad\qquad swap\;the\;i^{th}\;row\;with\;j^{th}\;row\\
&\qquad\qquad\qquad\qquad exch\gets true\\
&\qquad\qquad\qquad\qquad sign\gets -1\times sign\\
&\qquad\qquad if\;exch=false:\\
&\qquad\qquad\qquad return\;0;\\
&\qquad for\;\;k\gets i+1\;\;to\;\;n:\\
&\qquad\qquad A(k)\gets A(k)-A(i)\times\dfrac{A(k,i)}{A(i,i)}\\
&\qquad\qquad ret\gets ret\times A(i,i)\\
& return\;\; sign\times ret
\end{aligned}
$$

算法进行$n-1$次循环，每次循环利用倍加行变换将第$i$列的第$i+1$行至第$n$行的元素置为0，以此化成一个上三角矩阵，其行列式就是对角线的乘积。

在每一轮行变换开始之前，我们必须判断对角线元素是否为0，不然在

$$
A(k)\gets A(k)-A(i)\times\dfrac{A(k,i)}{A(i,i)}
$$

中会出现除0异常，所以我们可以将第$i$行与下面的某一行交换，当然这样的行要满足第$i$列元素不为0。如果找不到这样的行，说明第$i$行的第$i\sim n$列都是0，那么可以推得该行列式就是0。

我们找到这样的行后，就会对这两行进行交换，我们知道交换操作会导致$\det$成为其相反数，所以我们用`sign`来记录行交换次数，如果在整个算法中交换了偶数次，那么正好抵消，否则在计算出对角线乘积后还要取相反数才是最终结果。

时间复杂度：

$$
\begin{aligned}
T(n)&=\sum_{i=1}^{n-1}[O(n-i)+(n-i)\times n]=O(n^3)
\end{aligned}
$$

其中$O(n-i)$是向下搜索满足条件的行所需要的时间，$(n-i)\times n$就是倍增行变换的时间；

### Matrix-C中的行列式算法

在实际代码中，我们采取上面两种方法的折中：

$$
\begin{aligned}
&\det(A, n):\\
&if\;\;n=1:\\
&\qquad return\;\;A(1,1)\\
&exch\gets false\\
&if\;\;A(n,n)=0:\\
&\qquad for\;\;i\gets1\;\;to\;\;n-1:\\
&\qquad\qquad if\;\;A(i,n)\neq0:\\
&\qquad\qquad\quad swap\;the\;i^{th}\;row\;with\;n^{th}\;row\\
&\qquad\qquad\quad exch\gets true\\
&\qquad if\;\; exch\neq true:\\
&\qquad\qquad return\;\;0\\
&for\;\;j\gets 1\;\;to\;\;n-1:\\
&\qquad A(j)\gets A(j)-A(n)\times\dfrac{A(j,n)}{A(n,n)}\\
&if\;\;exch=false:\\
&\qquad return\;\;A(n,n)\times\det(A, n-1)\\
&else:\\
&\qquad return\;\;-A(n,n)\times\det(A, n-1)
\end{aligned}
$$

在算法中，我们将最后一列第$1\sim n-1$行的元素通过倍加行变换置为0，这样根据代数余子式的公式：

$$
\det(A)=a_{nn}A_{nn}
$$

$A_{nn}$则可以通过递归求出来，当然如果交换了行，由此产生的负号不能忘记了。

这样的写法本质上还是化为下三角矩阵求行列式，只不过通过递归减少了代码量，同时函数参数考虑了矩阵尺寸$n$，使得我们可以在不删除行/列的情况下计算代数余子式。

时间复杂度：

$$
T(n)=O(n^2)+T(n-1)=O(n^3)
$$

具体的代码实现可以参考[det in matrix-C](https://github.com/Kaslanarian/matrix-C/blob/master/src/math_helper.cc)，其中伪代码中的$A$是用指针实现的，使得递归中的行变换具有效性。

### 程序测试

运行程序：

{% codeblock lang:cpp %}
int main() {
    int n;
    std::cin >> n; // 输入方阵的size
    Matrix m = Matrix(n, n);
    std::cin >> m; // 输入矩阵
    std::cout << det(m) << std::endl;
    return 0;
}
{% endcodeblock %}

实现效果图：