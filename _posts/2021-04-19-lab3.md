---
layout:     post
title:      操作系统实验
subtitle:   进程切换
date:       2021-04-19
author:     Welt Xing
header-img: img/lab3/lab3_header.png
catalog:    true
tags:
    - 操作系统
---

## 前言

[实验手册](/file/lab3.pdf)，但内容比较像是往年的实验，因为存在与今年框架不相容的地方，但不是很影响阅读.

这次实验还是需要在$\text{Ubuntu 18.04}$及以下的内核版本上进行，否则会产生问题。

实验的必做内容比较简单，参考实验手册可完成不少.

这次实验涉及到C的进程编程，可以参考[C的进程编程](#[#19](https://github.com/Kaslanarian/Kaslanarian.github.io/issues/19)).

通过$\text{TODO Tree}$，我们可以更快的确定任务位置，此次任务主要是对`irqHandle.c`的增改. 我们将按照任务的难易程度来书写实验过程.

实验效果预览：

![lab3_video](/img/lab3/lab3.webp)

## 系统调用框架和库函数的补全

如讲义所言，这部分任务其实算是`lab2`的延申，根据`lib.h`提供的系统调用号：

```cpp
#define SYS_FORK  1
#define SYS_EXEC  2
#define SYS_SLEEP 3
#define SYS_EXIT  4
```

我们按此可以定义函数和将其嵌入框架（`syscallHandle`）：

```cpp
void syscallFork(struct StackFrame *sf);
void syscallExec(struct StackFrame *sf);
void syscallSleep(struct StackFrame *sf);
void syscallExit(struct StackFrame *sf);
```

我们在`syscallHandle`函数中加入上述系统调用函数：

```cpp
void syscallHandle(struct StackFrame *sf) {
    switch (sf->eax) {  // syscall number
        case 0:
            syscallWrite(sf);
            break;  // for SYS_WRITE
        case 1:
            syscallFork(sf);
            break;  // for SYS_FORK
        case 2:
            syscallExec(sf);
            break;  // for SYS_EXEC
        case 3:
            syscallSleep(sf);
            break;  // for SYS_SLEEP
        case 4:
            syscallExit(sf);
            break;  // for SYS_EXIT
        default:
            break;
    }
}
```

## 时钟中断的实现

首先我们要在`irqHandle`函数中注册时钟中断（b不要忘记栈指针的保存和恢复）：

```cpp
void irqHandle(struct StackFrame *sf) {
    ...
    uint32_t tmpStackTop = pcb[current].stackTop;
    pcb[current].prevStackTop = pcb[current].stackTop;
    pcb[current].stackTop = (uint32_t)sf;

    switch (sf->irq) {
            case -1:
                break;
            case 0xd:
                GProtectFaultHandle(sf);
                break;
            case 0x20:
                timerHandle(sf);
                break;
            case 0x80:
                syscallHandle(sf);
                break;
            default:
                assert(0);

    pcb[current].stackTop = tmpStackTop;
    ...
```

我们按照讲义的指导在时钟中断时的中断处理函数中实现进程的切换：

```cpp
void timeHandle(struct StackFrame *sf) {
    /* 
      遍历pcb，将状态为STATE_BLOCKED的进程的sleepTime减一，
      如果进程的sleepTime变为0，
      重新设为STATE_RUNNABLE
     */
    for (int i = 0; i < MAX_PCB_NUM; i++) {
        if (pcb[i].state == STATE_BLOCKED) {
            pcb[i].sleepTime--;
            if (pcb[i].sleepTime == 0) {
                pcb[i].state = STATE_RUNNABLE;
            }
        }
    }

    // 将当前进程的timeCount加一
    pcb[current].timeCount++;

    int i;
    /*
      如果时间片用完（timeCount==MAX_TIME_COUNT）
      且有其它状态为STATE_RUNNABLE的进程，切换
     */
    if (pcb[current].timeCount > MAX_TIME_COUNT) {
        pcb[current].state = STATE_RUNNABLE;
        pcb[current].timeCount = 0;
        for (i = (current + 1) % MAX_PCB_NUM; i != current;
             i = (i + 1) % MAX_PCB_NUM)
            if (pcb[i].state == STATE_RUNNABLE) break;
        current = i;
        pcb[current].state = STATE_RUNNING;
    }

    // 进程切换
    uint32_t tmpStackTop = pcb[current].stackTop;
    pcb[current].stackTop = pcb[current].prevStackTop;
    tss.esp0 = pcb[current].stackTop;
    tss.ss0 = KSEL(SEG_KDATA);
    asm volatile("movl %0, %%esp" : : "m"(tmpStackTop));
    asm volatile("popl %gs");
    asm volatile("popl %fs");
    asm volatile("popl %es");
    asm volatile("popl %ds");
    asm volatile("popal");
    asm volatile("addl $8, %esp");
    asm volatile("iret");
}
```

## 系统调用例程

### syscallFork

```cpp
void syscallFork(struct StackFrame *sf) {
    int i, j;
    // 寻找一个空闲的pcb做为子进程的进程控制块
    for (i = 0; i < MAX_PCB_NUM; i++) {
        if (pcb[i].state == STATE_DEAD) {
            break;
        }
    }
    if (i != MAX_PCB_NUM) {
        // 将父进程的资源复制给子进程
        // 开中断
        enableInterrupt();
        for (j = 0; j < 0x100000; j++) {
            *(uint8_t *)(j + (i + 1) * 0x100000) =
                *(uint8_t *)(j + (current + 1) * 0x100000);
        }
        // 关中断
        disableInterrupt();
        // 复制内核栈
        for (j = 0; j < sizeof(ProcessTable); ++j)
            *((uint8_t *)(&pcb[i]) + j) = *((uint8_t *)(&pcb[current]) + j);
        pcb[i].stackTop = (uint32_t) & (pcb[i].regs);
        pcb[i].prevStackTop = (uint32_t) & (pcb[i].stackTop);
        pcb[i].state = STATE_RUNNABLE;
        pcb[i].timeCount = 0;
        pcb[i].sleepTime = 0;
        pcb[i].pid = i;
        
        // 设置寄存器
        pcb[i].regs.ss = USEL(2 + 2 * i);
        pcb[i].regs.cs = USEL(1 + 2 * i);
        pcb[i].regs.ds = USEL(2 + 2 * i);
        pcb[i].regs.es = USEL(2 + 2 * i);
        pcb[i].regs.fs = USEL(2 + 2 * i);
        pcb[i].regs.gs = USEL(2 + 2 * i);
        
        // 设置返回值
        // 成功,子进程返回0
        pcb[i].regs.eax = 0;
        // 父进程返回子进程pid
        pcb[current].regs.eax = i;
    } else {
        // fork失败，父进程返回-1
        pcb[current].regs.eax = -1;
    }
    return;
}
```

### syscallSleep

这里我们有两个任务：

1. 将当前的进程的`sleepTime`设置为传入的参数，将当前进程的状态设置为  `STATE_BLOCKED`;
2. 模拟时钟中断，利用`timerHandle`进行进程切换.

```cpp
void syscallSleep(struct StackFrame *sf) {
    // 将当前的进程的sleepTime设置为传入的参数
    pcb[current].sleepTime = sf->ecx;
    // 模拟时钟中断，利用timerHandle进行进程切换.
    pcb[current].state = STATE_BLOCKED;

    // 仿照timerHandle进行进程切换
    int i;
    for (i = (current + 1) % MAX_PCB_NUM; i != current;
         i = (i + 1) % MAX_PCB_NUM)
        if (pcb[i].state == STATE_RUNNABLE) break;
    current = i;
    pcb[current].state = STATE_RUNNING;

    uint32_t tmpStackTop = pcb[current].stackTop;
    pcb[current].stackTop = pcb[current].prevStackTop;
    tss.esp0 = pcb[current].stackTop;
    tss.ss0 = KSEL(SEG_KDATA);
    asm volatile("movl %0, %%esp" : : "m"(tmpStackTop));
    asm volatile("popl %gs");
    asm volatile("popl %fs");
    asm volatile("popl %es");
    asm volatile("popl %ds");
    asm volatile("popal");
    asm volatile("addl $8, %esp");
    asm volatile("iret");
    return;
}
```

### syscallExit

这里还是有2个任务：

1. 将当前进程的状态设置为STATE_DEAD;
2. 模拟时钟中断进行进程切换.

```cpp
void syscallExit(struct StackFrame *sf) {
    // 将当前进程的状态设置为STATE_DEAD
    int i;
    for (i = (current + 1) % MAX_PCB_NUM; i != current;
         i = (i + 1) % MAX_PCB_NUM)
        if (pcb[i].state == STATE_RUNNABLE) break;
    current = i;
    pcb[current].state = STATE_RUNNING;

    // 仿照timerHandle进行进程切换
    ...
}
```

至此我们已经实现了进程切换：

![lab3_video](/img/lab3/lab3.webp)
