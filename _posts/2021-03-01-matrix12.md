---
layout:     post
title:      C++构建Matrix类(11)
subtitle:   实现QR分解，SVD分解
date:       2021-03-01
author:     Welt Xing
header-img: img/matrix_equations.png
catalog:    true
categories: matrix-c
tags:
    - matrix-c
    - 线性代数
---

# matrix-c实现QR分解和SVD分解

## QR分解

我们在之前提到过$QR$分解，其在求解矩阵特征值算法发挥重要作用，但当时只提供了分解的$QR$分解的接口，并没有详细讲解其分解的实现方法，我们这里来进行解释。

### 形式

QR分解将一个$m\times n(m\geq n)$矩阵分解为一个正交矩阵与一个上三角矩阵的积：

$$
A=QR\tag{1}
$$

Q是正交矩阵：

$$
Q^\top Q=I\tag{2}
$$

### 算法

QR分解的实际计算有很多方法，例如Givens旋转、Householder变换，以及Gram-Schmidt正交化等等。每一种方法都有其优点和不足。`matrix-c`采用施密特正交化进行求解。

我们可以用列向量的视角来看$QR$分解：

$$
\begin{aligned}
\begin{bmatrix}
\alpha_1&\alpha_2&\cdots&\alpha_n
\end{bmatrix}&=\begin{bmatrix}
\beta_1&\beta_2&\cdots&\beta_n
\end{bmatrix}\begin{bmatrix}
a_{11}&a_{12}&\cdots&a_{1n}\\
0&a_{22}&\cdots&a_{2n}\\
0 & 0&\ddots&a_{3n}\\
\vdots&\vdots&\vdots&\vdots\\
0&0&\cdots&a_{nn}
\end{bmatrix}\\
\end{aligned}\tag{3}
$$

可以证明上三角矩阵的逆矩阵还是上三角矩阵，所以我们可以得到：

$$
\begin{aligned}
\begin{bmatrix}
\alpha_1&\alpha_2&\cdots&\alpha_n
\end{bmatrix}\begin{bmatrix}
b_{11}&b_{12}&\cdots&b_{1n}\\
0&b_{22}&\cdots&b_{2n}\\
0 & 0&\ddots&b_{3n}\\
\vdots&\vdots&\vdots&\vdots\\
0&0&\cdots&b_{nn}
\end{bmatrix}&=\begin{bmatrix}
\beta_1&\beta_2&\cdots&\beta_n
\end{bmatrix}\\
&=\begin{bmatrix}
b_{11}\alpha_{1}&b_{12}\alpha_1+b_{22}\alpha_2&\cdots&\sum_{i=1}^nb_{in}\alpha_n
\end{bmatrix}
\end{aligned}\tag{4}
$$

也就是说，对于正交矩阵中的第$i$列向量$\beta_i$，我们可以通过$\alpha_1\sim\alpha_i$的线性组合得到，这正是施密特正交化的流程，在已有正交基的基础上构造一个新的正交基：![Schmidt](/img/Schmidt.jpg)

这里$\begin{bmatrix}\eta_1&\eta_2&\cdots&\eta_n\end{bmatrix}$就是一组标准正交基。

#### 实现施密特正交化

接下来我们将按照上面的伪代码进行施密特正交化的实现。

```cpp
matrix_pair SchmidtFullRank(Matrix A) {
    int row = A.get_row_number(), col = A.get_column_number();

    Matrix B = Matrix(row, col);       // β：未归一化的正交向量组
    Matrix norm_B = Matrix(row, col);  // η：归一化后的正交向量组

    for (int i = 0; i < col; i++) {
        for (int j = 0; j < row; j++) {
            B[j][i] = A[j][i];  // βi = αi
        }
        for (int j = 0; j < i; j++) {  // - <αi, ηj>·ηj
            double dot_pord = 0;
            for (int k = 0; k < row; k++) {
                dot_pord += A[k][i] * norm_B[k][j];
            }
            for (int k = 0; k < row; k++) {
                B[k][i] -= dot_pord * norm_B[k][j];
            }
        }
        double beta_norm = 0;
        for (int j = 0; j < row; j++) {  //||β||^2
            beta_norm += B[j][i] * B[j][i];
        }
        beta_norm = sqrt(beta_norm);
        for (int j = 0; j < row; j++) {  //ηi = β/||β||
            norm_B[j][i] = B[j][i] / beta_norm;
        }
    }
    return matrix_pair(B, norm_B);
}
```

注释对应施密特正交化中的算法步骤，接下来我们对矩阵

$$
\begin{bmatrix}
0&3&1\\
0&4&-2\\
2&1&1\\
\end{bmatrix}
$$

进行正交化处理：

```cpp
int main() {
    Matrix A = Matrix(3, 3);
    cin >> A;
    matrix_pair result = SchmidtFullRank(A);
    cout << "未归一化的结果：" << result.first << endl;
    cout << "归一化后的结果：" << result.second << endl;
    cout << "验证：" << result.second * result.second.transpose() << endl;
    return 0;
}
```

运行结果：![QR test](/img/QR_test2.png)

发现归一化后的矩阵$Q$满足$QQ^\top=I$，说明我们对其进行了成功的正交化。

#### 实现QR分解

我们已经通过施密特正交化实现了$Q$，那么我们就可以通过简单的矩阵乘法求得$R$:

```cpp
matrix_pair QR_decomposition(Matrix A) {
    Matrix Q = SchmidtFullRank(A).second;
    Matrix R = inv(Q) * A;
    return matrix_pair(Q, R);
}
```

我们还是使用上面提到的$3\times 3$矩阵作为测试样例：

```cpp
int main() {
    Matrix A = Matrix(3, 3);
    cin >> A;
    matrix_pair result = QR_decomposition(A);
    cout << A << " = " << result.first << " * " << result.second << endl;
    cout << "A - QR = " << A - result.first * result.second << endl;
    return 0;
}
```

测试结果如下：![test](/img/QR_test3.png)，可以发现分解结果是正确且符合形式的。

如果向`QR_decomposition`输入一个$4\times3$矩阵，算法会报错，因为`Q`是一个非方阵，无法求逆矩阵。所以我们需要对算法进行调整：

```cpp
matrix_pair Schmidt(Matrix A) {
    int row = A.get_row_number();
    int col = A.get_column_number();
    matrix_pair result;
    if (row > col) {
        result = NormalSchmidt(cat(A, rand_matrix(row, row - col, 0, 1)));
    } else if (row == col) {
        result = NormalSchmidt(A);
    } else {
        result = NormalSchmidt(split(A, row).first);
    }
    return result;
}
```

对施密特正交化进行修改：

1. 如果行数大于列数，那么将$m\times n$矩阵填充成$m\times m$矩阵，用随机数填充；

2. 如果行数等于列数，那么就正常正交化；

3. 如果行数小于列数，那么无法分解。

```cpp
matrix_pair QR_decomposition(Matrix A) {
    Assert(A.get_row_number() >= A.get_column_number(),
           "行数小于列数时无法分解");
    Matrix Q = Schmidt(A).second;
    Matrix R = inv(Q) * A;
    return matrix_pair(Q, R);
}
```

我们接着尝试分解一个随机非方阵：

```cpp
int main() {
    Matrix A = rand_matrix(4, 3, 0, 1);
    matrix_pair result = QR_decomposition(A);
    Matrix Q = result.first, R = result.second;
    cout << A << " = " << Q << " * " << R << endl;
    return 0;
}
```

分解结果：![m*n矩阵测试](/img/QR_test4.png)

至此我们已经实现了一个$QR$分解一个$m\times n$矩阵的模型。

