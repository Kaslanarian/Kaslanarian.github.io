---
layout:     post
title:      C++构建Matrix类(5)
subtitle:   求解线性方程组
date:       2021-02-23
author:     Welt Xing
header-img: img/matrix4_header.png
catalog:    true
tags:
    - 线性方程组
---

# 求解线性方程组——无解，唯一解和无穷解

## 关于线性方程组

初学者面对的线性方程组往往是最简单的：

$$
\begin{aligned}
x+y+z&=6\\
2x-y+3z&=8\\
-x+y+2z&=4
\end{aligned}
$$

等价于:

$$
\begin{bmatrix}
1&1&1\\
2&-1&3\\
-1&1&2\\
\end{bmatrix}
\begin{bmatrix}
x\\y\\z
\end{bmatrix}=\begin{bmatrix}
6\\8\\4
\end{bmatrix}
$$

由于这个$3\times3$矩阵行列式不为$0$,所以可以直接左乘逆矩阵：

$$
\begin{aligned}
Ax&=b\\
x&=A^{-1}b
\end{aligned}
$$

可以用在上一篇博文中所说的`inv`函数求解这个问题，解得：

$$
\begin{bmatrix}
x\\y\\z
\end{bmatrix}=\begin{bmatrix}
2\\2\\2
\end{bmatrix}
$$

但我们想要的是求解不同情况下的方程组，而不是像上面那样只有唯一解：

$$
A_{m\times n}x_{n\times1}=b_{m\times1}
$$

`matrix-C`采用的是较为标准的增广矩阵求解线性方程组：先将增广矩阵用行变换下三角化，此时就能判断解的情况，再分情况求解。

## 线性方程组解的结构

我们需要将增广矩阵$[A\;\;b]$化为阶梯型行列式：`lower_tri(A)`:

```cpp
Matrix lower_tri(Matrix m) {
    int row = m.get_row_number(), column = m.get_column_number();
    int row_ptr = 0, col_ptr = 0;

    while (row_ptr < row && col_ptr < column) {
        if (0 == m[row_ptr][col_ptr]) {
            bool replace = false;
            for (int i = row_ptr + 1; i < row; i++) {
                if (m[i][col_ptr] != 0) {
                    m.swap_row(row_ptr, i);
                    replace = true;
                    break;
                }
            }
            if (replace == false) {
                col_ptr++;
                continue;
            }
        }
        for (int i = row_ptr + 1; i < row; i++) {
            m.reduce_scale(i, row_ptr, m[row_ptr][col_ptr] / m[i][col_ptr]);
        }
        col_ptr++;
        row_ptr++;
    }
    vec2vec2double matrix = m.vec2vec();
    std::sort(matrix.begin(), matrix.end(), [](vec2double a, vec2double b) {
        int zero_a = 0, zero_b = 0;
        for (auto elem : a) {
            if (std::abs(elem) < 1e-10) {
                zero_a++;
            } else {
                break;
            }
        }
        for (auto elem : b) {
            if (std::abs(elem) < 1e-10) {
                zero_b++;
            } else {
                break;
            }
        }
        return (zero_a < zero_b);
    });
    return Matrix(matrix);
}
```