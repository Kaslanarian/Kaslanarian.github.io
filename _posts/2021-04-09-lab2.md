---
layout:     post
title:      操作系统实验
subtitle:   中断和系统调用
date:       2021-04-09
author:     Welt Xing
header-img: img/lab2_header.jpg
catalog:    true
tags:
---

## 前言

这是操作系统的第二次实验，首先，实验框架很大，需要一定时间去阅读以窥全貌；第二，该实验对设备有一定需求：Ubuntu20.04内核过新而不适用于该实验（体现在`qemu`在打印字符失败）；此外，实验涉及到的不只是操作系统中提及的中断等知识点，还涉及到一些编程任务，比如手写一个`printf`等；最后，$\text{TODO Tree}$和$\text{git}$是好东西。我们会按照[手册](/file/lab2.html)的指导顺序来书写实验报告。

## 模式跳转和程序加载

这部分其实是$\text{lab 1}$的任务，我们只在这里作简要概述。

我们有三个任务：

1. 补全`bootMain`，即内核程序加载；
2. 补全`loadUMain`，即用户程序加载；
3. 在`start.S`中设置`esp`，以实现跳转.

在任务一中，我们需要获取`kMainEntry`（程序入口）、`phoff`（程序头偏移）和`offset`（文件内便宜量）.

掌握可执行文件面向执行的`segment`视角以及`<elf.h>`库的使用就可以完成：

```cpp
typedef void (*VPVF)(void);
kMainEntry = (VPVF)((ElfHeader* elf))->entry;
phoff = ((ELFHeader *)elf)->phoff;
offset = ((ProgramHeader *)(elf + phoff))->off;
```

任务二是任务一的复用，我们仿照`bootMain`函数来补全`loadUMain`：

```cpp
void loadUMain(void) {
    int i = 0;
    int phoff = 0x34;        
    int offset = 0x1000;     
    uint32_t elf = 0x200000;
    uint32_t uMainEntry = 0x200000;

    for (i = 0; i < 200; i++) {
        readSect((void *)(elf + i * 512), 201 + i);
    }

    uMainEntry =
        ((struct ELFHeader *)elf)->entry;  // entry address of the program
    phoff = ((struct ELFHeader *)elf)->phoff;
    offset = ((struct ProgramHeader *)(elf + phoff))->off;

    for (i = 0; i < 200 * 512; i++) {
        *(uint8_t *)(elf + i) = *(uint8_t *)(elf + i + offset);
    }

    enterUserSpace(uMainEntry);
}
```

任务三需要我们将`esp`设置为合适的值，事实上，就是`TSS.esp0`的初始值：

```nasm
movl $0x1fffff, %eax
movl %eax, %esp
```

## 中断机制的实现

这部分我们还是有三个任务：

1. 将irqKeyboard的中断向量号压入栈（`doIrq.S`）；
2. 完善中断处理机制（`idt.c`）；
3. 补全中断处理程序（`irqHandle.c`）.

任务一不难，只需要知道键盘中断的中断向量号是0x21即可：

```nasm
.global irqKeyboard
irqKeyboard:
    pushl $0
    pushl $0x21
    jmp asmDoIrq
```

对于任务二，我们需要初始化门和IDT表。初始化门需要就是根据[讲义](/file/lab2.html)中的中断门和陷阱门结构就可以完成：

```cpp
/* 初始化一个中断门(interrupt gate) */
static void setIntr(struct GateDescriptor *ptr, uint32_t selector,
                    uint32_t offset, uint32_t dpl) {
    ptr->offset_15_0 = (uint16_t)(offset & 0xffff);
    ptr->segment = selector << 3;
    ptr->pad0 = 0;
    ptr->type = INTERRUPT_GATE_32;
    ptr->system = FALSE;
    ptr->privilege_level = dpl;
    ptr->present = TRUE;
    ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* 初始化一个陷阱门(trap gate) */
static void setTrap(struct GateDescriptor *ptr, uint32_t selector,
                    uint32_t offset, uint32_t dpl) {
    ptr->offset_15_0 = (uint16_t)(offset & 0xffff);
    ptr->segment = selector << 3;
    ptr->pad0 = 0;
    ptr->type = TRAP_GATE_32;
    ptr->system = FALSE;
    ptr->privilege_level = dpl;
    ptr->present = TRUE;
    ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}
```

IDT表的初始化就是利用`setTrap`函数将中断处理函数设置到IDT表中，并注明特权优先级：

```cpp
 /*
  * init your idt here
  * 初始化 IDT 表, 为中断设置中断处理函数
  */
 /* Exceptions with error code */
 setTrap(idt + 0x08, SEG_KCODE, (uint32_t)irqDoubleFault, DPL_KERN);
 setTrap(idt + 0x0a, SEG_KCODE, (uint32_t)irqInvalidTSS, DPL_KERN);
 setTrap(idt + 0x0b, SEG_KCODE, (uint32_t)irqSegNotPresent, DPL_KERN);
 setTrap(idt + 0x0c, SEG_KCODE, (uint32_t)irqStackSegFault, DPL_KERN);
 setTrap(idt + 0x0d, SEG_KCODE, (uint32_t)irqGProtectFault, DPL_KERN);
 setTrap(idt + 0x0e, SEG_KCODE, (uint32_t)irqPageFault, DPL_KERN);
 setTrap(idt + 0x11, SEG_KCODE, (uint32_t)irqAlignCheck, DPL_KERN);
 setTrap(idt + 0x1e, SEG_KCODE, (uint32_t)irqSecException, DPL_KERN);
 setTrap(idt + 0x21, SEG_KCODE, (uint32_t)irqKeyboard, DPL_KERN);

 /* Exceptions with DPL = 3 */
 setIntr(idt + 0x80, SEG_KCODE, (uint32_t)irqSyscall, DPL_USER);
 /* 写入IDT */
 saveIdt(idt, sizeof(idt));
```

任务三是让程序能够通过不同的`irq`（中断请求），来进行不同的处理：

```cpp
switch (tf->irq) {
    case -1:
        break;
    case 0x0d: // 一般保护错误
        GProtectFaultHandle(tf);
        break;
    case 0x21: // 键盘中断
        KeyboardHandle(tf);
        break;
    case 0x80: // 系统调用中断
        syscallHandle(tf);
        break;
    default:
        assert(0);

}
```

