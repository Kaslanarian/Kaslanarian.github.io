---
layout:     post
title:      C++构建矩阵类(10)
subtitle:   实现矩阵的LU分解
date:       2021-02-28
author:     Welt Xing
header-img: img/matrix_equations.png
---

# matrix-c实现矩阵的LU分解

## 引入

在维基百科中，归纳了几类矩阵分解：

1. LU分解

2. 奇异值分解

3. QR分解

4. 极分解

5. 特征分解

6. 主成分分析

我们已经在前面剖析了特征分解的形式和方法，而极分解的对象是复系数矩阵，无法在`matrix-c`中实现，所以我们将尝试实现其他几类分解。

## LU分解

### 基本的LU分解

#### 形式

LU分解是要将一个$n\times n$矩阵分解为一个下三角矩阵和上三角矩阵的乘积：

$$
A=\begin{bmatrix}
a_{11}&a_{12}&a_{13}\\
a_{21}&a_{22}&a_{23}\\
a_{31}&a_{32}&a_{33}\\
\end{bmatrix}=\begin{bmatrix}
l_{11}&0&0\\
l_{21}&l_{22}&0\\
l_{31}&l_{32}&l_{33}\\
\end{bmatrix}\begin{bmatrix}
u_{11}&u_{12}&u_{13}\\
0&u_{22}&u_{23}\\
0&0&u_{33}\\
\end{bmatrix}
$$

事实上，并不是每个矩阵都有LU分解。例如从上面可以知道$a_{11}=l_{11}u_{11}$，如果$a_{11}=0$，那么$l_{11}=0$或$u_{11}=0$，所以$L$或者$U$就变成了不可逆矩阵，$A$也必须是不可逆矩阵，但实际上存在$a_{11}=0$但可逆的矩阵，那这些矩阵就是不可LU分解的。

#### 方法

LU分解在本质上就是高斯消元法的一种表达形式。实质上是将A通过初等行变换变成一个上三角矩阵，其变换矩阵就是一个单位下三角矩阵。这正是所谓的杜尔里特算法（Doolittle algorithm）：对矩阵A做初等行变换，将对角线左下方的元素变成零，然后再证明这些行变换的效果等同于左乘一系列单位下三角矩阵，这一系列单位下三角矩阵的乘积的逆就是L矩阵，它也是一个单位下三角矩阵：

$$
\begin{aligned}
A &=A\\
XA&=U\\
 A&=X^{-1}U\\
 A&=LU\\
\end{aligned}
$$

回忆我们在求逆矩阵时使用的高斯消元法，那是我们需要将$(A\|E)$化成$(E\|A^{-1})$，也就是先化为$(U\|X)$再化为$(E\|A^{-1})$，但此时我们只需要进行一半的工作就行了。此外，这里是不允许对角线元素出现$0$，否则我们就会将算法停止，我们在之后会介绍如何处理这个问题。

```cpp
matrix_pair LU_decomposition(Matrix A) {
    int row = A.get_row_number(), col = A.get_column_number();

    Matrix right = eye(row);
    Matrix augmented = *cat(&A, &right);

    for (int i = 0; i < row; i++) {
        // 如果遇到对角线元素为0则报错
        Assert(0 != augmented[i][i], "diagonal element can't be 0 in LU");
        augmented.scale(i, augmented[i][i]);
        for (int j = i + 1; j < row; j++) {
            if (0 != augmented[j][i]) {
                augmented.scale(j, augmented[j][i]);
                augmented.reduce(j, i);
            }
        }
    }
    for (int i = 0; i < row; i++) {
        // 习惯上LU分解中的L的对角线上全1
        augmented.scale(i, augmented[i][i + col]);
    }
    matrix_pair ans = split(&augmented, row, 0);  // XA|X
    Matrix U = ans.first;
    Matrix L = inv(ans.second);
    return matrix_pair(L, U);
}
```

#### 程序测试

我们尝试对矩阵

$$
\begin{bmatrix}
1&2&3\\2&5&7\\3&5&3\\
\end{bmatrix}
$$

进行LU分解：

```cpp
int main() {
    Matrix A = Matrix(3, 3);
    cin >> A;
    matrix_pair result = LU_decomposition(A);
    cout << A << " = " << result.first << " * " << result.second << endl;
    cout << "A - LU = " << A - result.first * result.second << endl;
    return 0;
}
```

发现LU分解成功：![测试结果](/img/LUtest.png)

事实上，我们可以发现杜尔利特算法也是可以接受非方阵的：

$$
A_{m\times n}=L_{m\times m}U_{m\times n}
$$

我们尝试分解$3\times4$矩阵

$$
\begin{bmatrix}
3&5&7&6\\
1&5&3&2\\
0&1&2&4\\
\end{bmatrix}
$$

分解结果：![分解结果](/img/LUtest2.png)

### LDU分解

通常我们会要求LU分解后L矩阵的对角线全1，而U并未做要求；LDU分解则是将矩阵分解为一个单位下三角矩阵$L$，对角矩阵$D$和单位上三角矩阵$U$，我们只需要对LU分解后的结果稍作修改即可：

```cpp
matrix_tuple LDU_decomposition(Matrix A) {
    matrix_pair LUresult = LU_decomposition(A);
    int row = LUresult.second.get_row_number();
    Matrix L = LUresult.first;
    Matrix D = Matrix(row, row);
    Matrix U = LUresult.second;
    for (int i = 0; i < row; i++) {
        D[i][i] = U[i][i];
        U.scale(i, U[i][i]);
    }
    return matrix_tuple(L, D, U);
}
```

运行测试程序：

```cpp
int main() {
    Matrix A = Matrix(3, 3);
    cin >> A;
    matrix_tuple result = LDU_decomposition(A);
    Matrix L = get<0>(result);
    Matrix D = get<1>(result);
    Matrix U = get<2>(result);
    cout << A << " = " << L << " * " << D << " * " << U << endl;
    cout << "A - LDU = " << A - L * D * U << endl;
    return 0;
}
```

测试结果：![LDUtest](/img/LDU_test.png)

### PLU分解

我们之前提到LU分解在遇到$A_{ii}=0$的情况下必须中止，原因是如果此时交换行的话，会对$L$，$U$的三角结构产生破坏，但解决方案是有的，我们可以用额外一个矩阵$P$来表示行交换的过程，$P$也被称作**置换矩阵**：

$$
\begin{aligned}
A  &= A\\
XYA&= U\\
  A&=Y^{-1}X^{-1}U\\
  A&=PLU
\end{aligned}
$$

所以$Y$对应的是行交换，$X$仍对应的是行倍增和行加减。我们需要先进行行交换使得对角线元素没有0，再进行上面的基本LU分解：

```cpp
matrix_tuple PLU_decomposition(Matrix A) {
    int n = A.get_row_number();
    Matrix Y = eye(n);
    for (int i = 0; i < n; i++) {
        if (A[i][i] == 0) {
            bool replace = false;
            for (int j = i + 1; j < n; j++) {
                if (A[j][i] != 0) {
                    Y.swap_row(i, j);
                    replace = true;
                    break;
                }
            }
            Assert(replace, "PLU decomposition fail");
        }
    }
    matrix_pair LUresult = LU_decomposition(Y * A);
    matrix_tuple ret;
    std::get<0>(ret) = Y.transpose();
    std::get<1>(ret) = LUresult.first;
    std::get<2>(ret) = LUresult.second;
    return ret;
}
```

我们尝试对矩阵

$$
\begin{bmatrix}
1&3&7\\
6&0&4\\
5&2&3\\
\end{bmatrix}
$$

进行PLU分解：

分解结果：![PLUtest](/img/PLUtest.png)

## 应用

### 求解线性方程组

LU分解可以提高求解线性方程组的效率：

$$
Ax=b\tag{1}
$$

$$
A=LU\tag{2}
$$

所以我们需要先解方程组

$$
Ly=b\tag{3}
$$

得到$y$，再解方程组

$$
Ux=y\tag{4}
$$

得到$x$，在两次的求解中，我们遇到的都是三角矩阵，因此运用向前（向后）替代法就可以简洁地求解：

$$
\begin{bmatrix}
1&2&3\\2&5&7\\3&5&3\\
\end{bmatrix}\begin{bmatrix}
x_1\\x_2\\x_3
\end{bmatrix}=\begin{bmatrix}6\\14\\11
\end{bmatrix}\tag{1}
$$

由上面LU分解结果：

$$
\begin{bmatrix}
1&2&3\\2&5&7\\3&5&3\\
\end{bmatrix}=\begin{bmatrix}
1&0&0\\2&1&0\\3&-1&1
\end{bmatrix}\begin{bmatrix}
1&2&3\\0&1&1\\0&0&-5
\end{bmatrix}\tag{2}
$$

我们先解方程组

$$
\begin{bmatrix}
1&0&0\\2&1&0\\3&-1&1
\end{bmatrix}\begin{bmatrix}
y_1\\y_2\\y_3
\end{bmatrix}=\begin{bmatrix}6\\14\\11
\end{bmatrix}\tag{3}
$$

我们只需要不断向后替代就可以得到解：

$$
\begin{cases}
y_1=6\\y_2=2\\y_3=-5
\end{cases}\tag{4}
$$

接着来解方程组

$$
\begin{bmatrix}
1&2&3\\0&1&1\\0&0&-5
\end{bmatrix}\begin{bmatrix}
x_1\\x_2\\x_3
\end{bmatrix}=\begin{bmatrix}
6\\2\\-5
\end{bmatrix}
$$

不断向前替代得到最终解：

$$
\begin{cases}
x_1=1\\x_2=1\\x_3=1
\end{cases}
$$

### 求行列式

LU分解也可以用于求解行列式：

$$
\det(A)=\det(LU)=\det(L)\det(U)=\prod_{i=1}^n L_{ii}\prod_{i=1}^nU_{ii}
$$
