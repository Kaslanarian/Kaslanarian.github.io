---
layout:     post
title:      演化算法：表示、突变与重组(2)
subtitle:   排列表示与树表示
date:       2021-11-13
author:     Welt Xing
header-img: img/hsae/hsae.png
catalog:    true
tags:
    - 演化算法
---

我们这里介绍最后两种解的表示：排列表示(Permutation representation)和树表示(Tree representation)。

## <center>排列表示

虽然形式和整数表示相似，但属于不同的逻辑。比如在八皇后问题中，下面的棋盘

![image-20211112105157700](/img/hsae/image-20211112105157700.png)

的整数表示为

$$
\begin{bmatrix}
1&6&2&5&7&4&8&3
\end{bmatrix}
$$

而在旅行商问题中，城市遍历的顺序也可以是

$$
\begin{bmatrix}
1&6&2&5&7&4&8&3
\end{bmatrix}
$$

但第一种是整数表示，但恰好是一个组合的形式；第二种是组合表示，这是由旅行商问题的限制决定的。

排列表示的形式是一个指定集合的排列，可以有两种编码方式：

1. 事件在第$i$位发生；
2. 第$i$件事件发生的位置。

比如采用第一种编码方式的排列表示

$$
\begin{bmatrix}
1&6&2&5&7&4&8&3
\end{bmatrix}
$$

事件1在第1位发生，事件2在第6位发生，事件3在第二位发生......；采用第二种编码方式，编码变成：

$$
\begin{bmatrix}
1&3&8&6&4&2&5&7
\end{bmatrix}
$$

但两者解码后含义等价。

### 排列表示下的变异

排列表示下，突变不能随机，比如

$$
\begin{bmatrix}
1&6&2&5&7&4&8&3
\end{bmatrix}\to\begin{bmatrix}
1&4&2&5&7&4&7&3
\end{bmatrix}
$$

变异之后，新子代不再是一个排列了。因此，排列表示的突变需要新的方式：

- 交换(Swap mutation)；
- 插入(Insert mutation);
- 争夺(Scramble mutation);
- 逆转(Inversion mutation).

#### 交换变异

交换变异就是在排列中随机选两个位置，将元素进行交换，这样形成的还是一个排列：

$$
\begin{bmatrix}
1&\pmb6&2&5&\pmb7&4&8&3
\end{bmatrix}\to\begin{bmatrix}
1&\pmb7&2&5&\pmb6&4&8&3
\end{bmatrix}
$$

#### 插入变异

插入变异：随机选两个位置，将第二个位置的元素移到第一个元素的正后面：

$$
\begin{bmatrix}
1&\pmb6&2&5&\pmb7&4&8&3
\end{bmatrix}\to\begin{bmatrix}
1&\pmb6&\pmb7&2&5&4&8&3
\end{bmatrix}
$$

它保留了大部分顺序信息和邻近信息。

#### 争夺变异

随机选择位置的子集，然后随机重排：

$$
\begin{bmatrix}
1&\pmb6&2&5&\pmb7&\pmb4&\pmb8&3
\end{bmatrix}\to\begin{bmatrix}
1&\pmb8&2&5&\pmb6&\pmb7&\pmb4&3
\end{bmatrix}
$$

#### 逆转变异

随机选择两个位置，将这两位之间的元素全部逆转：

$$
\begin{bmatrix}
1&\pmb6&\pmb2&\pmb5&\pmb7&4&8&3
\end{bmatrix}\to\begin{bmatrix}
1&\pmb7&\pmb5&\pmb2&\pmb6&4&7&3
\end{bmatrix}
$$

### 排列表示下的重组

显然，对于排列表示的重组也不能随机重组，因为生成的子代有概率不是排列。排列表示的重组方法：

- Partially mapped crossover;
- Edge crossover;
- Order crossover;
- Cycle crossover.

我们来一一介绍这些重组方法：

#### Partially mapped crossover

步骤如下(直接翻译)：

1. 随机选择两个交叉点，然后将父代解1中两点间的部分复制下给子代解1；
2. 从第一个交叉点开始，寻找父代解2在两点间元素中未被复制的部分；
3. 对于每一个$i$​，查看其后代，看看𝑗有什么元素是从父代解1那里复制过来的；
4. 把𝑖放在父代解2中的𝑗所占据的位置，因为我们知道不会把𝑗放在那里(因为已经在后代中)；
5. 如果父代解2中𝑗所占的位置已经被填满，把𝑖放在父代解2中𝑘的位置；
6. 在处理了交叉部分的元素之后，剩下的父代解2可以填充第一个后代；
7. 以父母角色相反的方式创造第二个后代；

举例，现在我们有待重组的父代解：

$$
\begin{bmatrix}
1&2&3&4&5&6&7&8&9\\
9&3&7&8&2&6&5&1&4
\end{bmatrix}
$$

1. 随机选择交叉点：第4位和第7位，子代解1（-1表示未确定元素）：

   $$
   \begin{bmatrix}
   -1&-1&-1&4&5&6&7&-1&-1\\
   \end{bmatrix}
   $$

2. 从第4位开始，找父代解2的第4位和第7位之间不同于父代解1在该区间的元素，这里是8、2、6、5，其中5和6与子代解1重复，因此选择8和2；

3. 找对应：父代解1中4对应父代解2中的8，而父代解2中的4在最后一位，因此子代的最后一位是8；父代解1中5对应父代解2中的2，而父代解2中的5在两个随机选择的交叉点内，因此找父代解2中的5与父代解1对应的元素，是7，其在父代解2中对应的是第3位，在交叉点框定范围之外，因此子代解1的第3位是2：

   $$
   \begin{bmatrix}
   -1&-1&2&4&5&6&7&-1&8\\
   \end{bmatrix}
   $$

4. 将父代解2剩余的元素填充子代解1：

   $$
   \begin{bmatrix}
   9&3&2&4&5&6&7&1&8\\
   \end{bmatrix}
   $$

5. 用同样的方式构造第二个子代。

过程图示如下：

<img src="/img/hsae/image-20211113105257416.png" alt="image-20211113105257416" style="zoom:67%;" />

#### Edge crossover

构建一个列表表格(table listing)，用来记录父代解中指定元素的邻居元素(edge)，理论上说会4个edge，但如果存在重复元素，我们会在后面标记一个"+"，举个例子，现在我们有待重组的父代解：

$$
\begin{bmatrix}
1&2&3&4&5&6&7&8&9\\
9&3&7&8&2&6&5&1&4
\end{bmatrix}
$$

然后就可以列出表格

| Element |  Edges  |
| :-----: | :-----: |
|    1    | 2,5,4,9 |
|    2    | 1,3,6,8 |
|    3    | 2,4,7,9 |
|    4    | 1,3,5,9 |
|    5    | 1,4,6+  |
|    6    | 2,5+,7  |
|    7    | 3,6,8+  |
|    8    | 2,7+,9  |
|    9    | 1,3,4,8 |

在构建出这样一表格之后，我们需要：

1. 选一个初始元素和entry，将其放入子代；
2. 设变量“当前元素”的值为entry；
3. 移除表中所有指向当前元素的元素；
4. 检查当前元素的列表：
   - 如果有公共边，选择它称为下一个元素；
   - 否则，选择有最短列表的元素作为entry;
   - Ties are split at random；
5. 如果形成了一个空列表，则随机再选一个元素。

以上面的父代解为例：

![image-20211113111033885](/img/image-20211113111033885.png)

#### Order crossover

1. 随机选择两个交叉点；
2. 将父代解1两个交叉点内的部分复制到子代解1的相同位置；
3. 将不在上述部分的元素复制到子代解1，遵从如下规则：
   - 从第二个交叉点开始；
   - 以父代解2的顺序；
   - 如果遍历到达尾部，跳转到头部，继续遍历.
4. 用相同的方式创建子代解2，只不过两父代解角色互换。

还是以上面的父代解为例，选择第4位和第7位，父代解1就是

$$
\begin{bmatrix}
-1&-1&-1&4&5&6&7&-1&-1\\
\end{bmatrix}
$$

然后从7的后面开始，元素排列按照父代解2的顺序，也就是：

$$
1\to(4)\to9\to3\to(7)\to8\to2\to(6)\to(5)
$$

注意：

1. 上面有括号的元素已经出现在了子代解1中，所以需要跳过；
2. 在4之后，遍历到达尾部，此时要跳转到头部，也就是9，继续遍历。

因此子代解1为

$$
\begin{bmatrix}
3&8&2&4&5&6&7&1&9\\
\end{bmatrix}
$$

子代解2按照类似的方式构造，只是父代解1和2角色互换。

#### Cycle crossover

为什么叫“Cycle”，因为该方法就是在两个父代解序列中，利用等位基因找一个圈。“等位基因”在这里就是两父代解中位置相同的元素。具体步骤如下：

1. 从父代解1的第一个未被使用的位置开始；
2. 找父代解2中的等位基因；
3. 将等位基因的元素作为位置，对父代解1进行寻址；
4. 将这个等位基因加入圈；
5. 重复2-4步直到回到了第一步所说的位置；
6. 通过选择交替的圈来从每个父代创造后代.

举例：

![image-20211113114643122](/img/image-20211113114643122.png)

#### 重组总结

Partially mapped crossover和Edge crossover是将两个父代解的邻近信息赋给了子代；而Order crossover和Cycle crossover是将父代解的顺序信息给了子代。

## <center>树表示

树形结构的解表示，可用于程序设计、数学表达式、逻辑表达式等场景。比如

```c
i = 1;
while (i < 20) {
    i = i + 1;
}
```

对应的树形式可以是

<img src="/img/hsae/image-20211113115924059.png" alt="image-20211113115924059" style="zoom:67%;" />

再比如数学表达式

$$
2\cdot\pi+\bigg((x+3)-\frac{y}{5+1}\bigg)
$$

就可以写成

<img src="/img/hsae/image-20211113120042079.png" alt="image-20211113120042079" style="zoom:67%;" />

逻辑表达式也可以采用树形式，比如逻辑表达式

$$
(x\wedge\text{True})\to((x\vee y)\vee(z\leftrightarrow(x\wedge y)))
$$

对应树表示：

![image-20211113120413605](/img/image-20211113120413605.png)

### 树表示的突变

树的突变就是随机选择一个子树替换成一个随机生成的树：

<img src="/img/hsae/image-20211113120600769.png" alt="image-20211113120600769" style="zoom:80%;" />

### 树表示的重组

树表示下的重组，就是在两棵父代树中各自随机选择两棵，然后互相交换：

<img src="/img/hsae/image-20211113132821507.png" alt="image-20211113132821507" style="zoom:80%;" />

## <center>关于突变与重组

到底两者中哪个更好？这一争论持续了几十年：演化编程(Evolutinary programming)没有重组的概念，而基因编程(Genetic programming)是没有突变的。重组是具有探索性的，可以带来很大的飞跃；突变是具有利用性的，它创造了很小的差异。在现代，我们通常会将两者都纳入到演化算法中。

## <center>总结

我们在这里介绍了更复杂的解表示：排列表示与树表示，以及对应的变异方式，同时也对两种变异方式：突变和重组进行了小的总结。
