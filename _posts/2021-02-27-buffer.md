---
layout:     post
title:      关于C/C++缓冲区的问题
subtitle:   探究：溢出和清理
date:       2021-02-27
author:     Welt Xing
header-img: img/buffer.jpg
catalog:    true
categories: matrix-c
tags:
    - C/C++
    - 输入输出
---

## 引入

当我们运行这样的程序：

```cpp
#include <stdio.h>
int main() {
    int a, b;
    while(scanf("%d%d", &a, &b)) {
        printf("a : %d, b = %d\n", a, b);
    }
    return 0;
}
```

该程序会接受两个输入，赋值给`a`和`b`，然后输出它们的值：

```text
1 2
a : 1, b : 2
3 4
a : 3, b : 4
```

我们再进行这样的测试：

```text
1 2 3
a : 1, b : 2
4
a : 3, b : 4
```

发现我们在第一次输入中多余的内容，会在第二次输出。我们发现这个模型与一个队列(queue)相似：

1. 第一次向队列里输入三个元素1，2，3；

    ```cpp
    queue.push(1);
    queue.push(2);
    queue.push(3);
    ```

    此时的队列：队列尾端$\to\begin{bmatrix}3&2&1\end{bmatrix}\to$队列首端。

2. `scanf`函数让队列推出两个元素，按顺序赋值给`a`和`b`：

    ```cpp
    a = queue.pop();
    b = queue.pop();
    ```

    此时的队列：队列尾端$\to\begin{bmatrix}3\end{bmatrix}\to$队列首端，第一个被推出的是$1$，所以`a`被赋为1，第二个被推出的是$2$，所以`b`被赋值为2。

3. 第二次输入4：

    ```cpp
    queue.push(4);
    ```

    此时的队列：队列尾端$\to\begin{bmatrix}4&3\end{bmatrix}\to$队列首端。

4. `scanf`函数再次让队列推出两个元素，按顺序赋值给`a`和`b`：

    ```cpp
    a = queue.pop();
    b = queue.pop();
    ```

    此时的队列：队列尾端$\to\begin{bmatrix}\end{bmatrix}\to$队列首端，第一个被推出的是$3$，所以`a`被赋为3，第二个被推出的是$4$，所以`b`被赋值为4。

缓冲区(buffer)就是这样的队列。